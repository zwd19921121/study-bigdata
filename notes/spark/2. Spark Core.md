# Spark Core

## 1 RDD概述

### 1.1 什么是 RDD

RDD（Resilient Distributed Dataset）叫做弹性分布式数据集，是Spark中最基本的数据抽象。

在代码中是一个抽象类，它代表一个弹性的、不可变、可分区、里面的元素可并行计算的集合。

### 1.2 RDD 的 5 个主要属性(property)

* A list of partitions

​       多个分区. 分区可以看成是数据集的基本组成单位.

​       对于 RDD 来说, 每个分区都会被一个计算任务处理, 并决定了并行计算的粒度.

​       用户可以在创建 RDD 时指定 RDD 的分区数, 如果没有指定, 那么就会采用默认值. 默认值就是程序所分配到的 CPU Coure 的数目.

​       每个分配的存储是由BlockManager 实现的. 每个分区都会被逻辑映射成 BlockManager 的一个 Block, 而这个 Block 会被一个 Task 		负责计算.

* A function for computing each split

​       计算每个切片(分区)的函数.

​       Spark 中 RDD 的计算是以分片为单位的, 每个 RDD 都会实现 compute 函数以达到这个目的.

* A list of dependencies on other RDDs

​       与其他 RDD 之间的依赖关系

​       RDD 的每次转换都会生成一个新的 RDD, 所以 RDD 之间会形成类似于流水线一样的前后依赖关系. 在部分分区数据丢失时, Spark 可		以通过这个依赖关系重新计算丢失的分区数据, 而不是对 RDD 的所有分区进行重新计算.

* Optionally, a Partitioner for key-value RDDs (e.g. to say that the RDD is hash-partitioned)

​       对存储键值对的 RDD, 还有一个可选的分区器.

​       只有对于 key-value的 RDD, 才会有 Partitioner, 非key-value的 RDD 的 Partitioner 的值是 None. Partitiner 不但决定了 RDD 的本区	   数量, 也决定了 parent RDD Shuffle 输出时的分区数量.

* Optionally, a list of preferred locations to compute each split on (e.g. block locations for an HDFS file)

​       存储每个切片优先(preferred location)位置的列表. 比如对于一个 HDFS 文件来说, 这个列表保存的就是每个 Partition 所在文件块的	   位置. 按照“移动数据不如移动计算”的理念, Spark 在进行任务调度的时候, 会尽可能地将计算任务分配到其所要处理数据块的存储位置.

### 1.3 理解RDD

一个 RDD 可以简单的理解为一个分布式的元素集合.

RDD 表示只读的分区的数据集，对 RDD 进行改动，只能通过 RDD 的转换操作, 然后得到新的 RDD, 并不会对原 RDD 有任何的影响

在 Spark 中, 所有的工作要么是创建 RDD, 要么是转换已经存在 RDD 成为新的 RDD, 要么在 RDD 上去执行一些操作来得到一些计算结果.

每个 RDD 被切分成多个分区(partition), 每个分区可能会在集群中不同的节点上进行计算.

#### 1.3.1 RDD 特点

##### 1.3.1.1 弹性

* 存储的弹性：内存与磁盘的自动切换；

* 容错的弹性：数据丢失可以自动恢复；

* 计算的弹性：计算出错重试机制；

* 分片的弹性：可根据需要重新分片。

##### 1.3.1.2 分区

RDD 逻辑上是分区的，每个分区的数据是抽象存在的，计算的时候会通过一个compute函数得到每个分区的数据。

如果 RDD 是通过已有的文件系统构建，则compute函数是读取指定文件系统中的数据，如果 RDD 是通过其他 RDD 转换而来，则 compute函数是执行转换逻辑将其他 RDD 的数据进行转换。

##### 1.3.1.3   只读

RDD 是只读的，要想改变 RDD 中的数据，只能在现有 RDD 基础上创建新的 RDD。

由一个 RDD 转换到另一个 RDD，可以通过丰富的转换算子实现，不再像 MapReduce 那样只能写map和reduce了。

RDD 的操作算子包括两类，

* 一类叫做transformation，它是用来将 RDD 进行转化，构建 RDD 的血缘关系；

* 另一类叫做action，它是用来触发 RDD 进行计算，得到 RDD 的相关计算结果或者 保存 RDD 数据到文件系统中.

##### 1.3.1.4   依赖(血缘)

RDDs 通过操作算子进行转换，转换得到的新 RDD 包含了从其他 RDDs 衍生所必需的信息，RDDs 之间维护着这种血缘关系，也称之为依赖。

如下图所示，依赖包括两种，

* 一种是窄依赖，RDDs 之间分区是一一对应的，

* 另一种是宽依赖，下游 RDD 的每个分区与上游 RDD(也称之为父RDD)的每个分区都有关，是多对多的关系。

![依赖](https://gitee.com/zhdoop/blogImg/raw/master/img/Spark-依赖.png)

##### 1.3.1.5   缓存

如果在应用程序中多次使用同一个 RDD，可以将该 RDD 缓存起来，该 RDD 只有在第一次计算的时候会根据血缘关系得到分区的数据，在后续其他地方用到该 RDD 的时候，会直接从缓存处取而不用再根据血缘关系计算，这样就加速后期的重用。

如下图所示，RDD-1 经过一系列的转换后得到 RDD-n 并保存到 hdfs，RDD-1 在这一过程中会有个中间结果，如果将其缓存到内存，那么在随后的 RDD-1 转换到 RDD-m 这一过程中，就不会计算其之前的 RDD-0 了。

![缓存](https://gitee.com/zhdoop/blogImg/raw/master/img/Spark-缓存.png)

##### 1.3.1.6   checkpoint

虽然 RDD 的血缘关系天然地可以实现容错，当 RDD 的某个分区数据计算失败或丢失，可以通过血缘关系重建。

但是对于长时间迭代型应用来说，随着迭代的进行，RDDs 之间的血缘关系会越来越长，一旦在后续迭代过程中出错，则需要通过非常长的血缘关系去重建，势必影响性能。

为此，RDD 支持checkpoint 将数据保存到持久化的存储中，这样就可以切断之前的血缘关系，因为checkpoint 后的 RDD 不需要知道它的父 RDDs 了，它可以从 checkpoint 处拿到数据。

## 2 RDD 编程

### 2.1 RDD 编程模型

在 Spark 中，RDD 被表示为对象，通过对象上的方法调用来对 RDD 进行转换。

经过一系列的transformations定义 RDD 之后，就可以调用 actions 触发 RDD 的计算

action可以是向应用程序返回结果(count, collect等)，或者是向存储系统保存数据(saveAsTextFile等)。

在Spark中，只有遇到action，才会执行 RDD 的计算(即延迟计算)，这样在运行时可以通过管道的方式传输多个转换。

要使用 Spark，开发者需要编写一个 Driver 程序，它被提交到集群以调度运行 Worker.Driver 中定义了一个或多个 RDD，并调用 RDD 上的 action，Worker 则执行 RDD 分区计算任务

### 2.2 RDD的创建

在 Spark 中创建 RDD 的方式可以分为 3 种：

* 从集合中创建 RDD

* 从外部存储创建 RDD

* 从其他 RDD 转换得到新的 RDD。

#### 2.2.1  从集合中创建 RDD

##### 2.2.1.1   使用parallelize函数创建

```scala
scala> val arr = Array(10,20,30,40,50,60)
arr: Array[Int] = Array(10, 20, 30, 40, 50, 60)

scala> val rdd1 = sc.parallelize(arr)
rdd1: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[0] at parallelize at <console>:26
```

##### 2.2.1.2   使用makeRDD函数创建

```scala
makeRDD和parallelize是一样的.
scala> val rdd1 = sc.makeRDD(Array(10,20,30,40,50,60))
rdd1: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[0] at makeRDD at <console>:24
```

说明:

* 一旦 RDD 创建成功, 就可以通过并行的方式去操作这个分布式的数据集了.

* parallelize和makeRDD还有一个重要的参数就是把数据集切分成的分区数.

* Spark 会为每个分区运行一个任务(task). 正常情况下, Spark 会自动的根据你的集群来设置分区数

#### 2.2.2  从外部存储创建 RDD

Spark 也可以从任意 Hadoop 支持的存储数据源来创建分布式数据集.

可以是本地文件系统, HDFS, Cassandra, HVase, Amazon S3 等等.

Spark 支持 文本文件, SequenceFiles, 和其他所有的 Hadoop InputFormat.

```scala
scala> var distFile = sc.textFile("words.txt")
distFile: org.apache.spark.rdd.RDD[String] = words.txt MapPartitionsRDD[1] at textFile at <console>:24
scala> distFile.collect
res0: Array[String] = Array(atguigu hello, hello world, how are you, abc efg)
```

说明:

1. url可以是本地文件系统文件, hdfs://..., s3n://...等等

2. 如果是使用的本地文件系统的路径, 则必须每个节点都要存在这个路径

3. 所有基于文件的方法, 都支持目录, 压缩文件, 和通配符(*). 例如: 

```shell
textFile("/my/directory"), textFile("/my/directory/*.txt"), and textFile("/my/directory/*.gz").
```

4. textFile还可以有第二个参数, 表示分区数. 默认情况下, 每个块对应一个分区.(对 HDFS 来说, 块大小默认是 128M). 可以传递一个大于块数的分区数, 但是不能传递一个比块数小的分区数.

5. 关于读取文件和保存文件的其他知识, 后面专门的章节介绍.

#### 2.2.3  从其他 RDD 转换得到新的 RDD

就是通过 RDD 的各种转换算子来得到新的 RDD.

### 2.3 RDD 的转换(transformation)

在 RDD 上支持 2 种操作:

1. transformation

从一个已知的 RDD 中创建出来一个新的 RDD 例如: map就是一个transformation.

2. action

在数据集上计算结束之后, 给驱动程序返回一个值. 例如: reduce就是一个action.

本节学习 RDD 的转换操作, Action操作下节再学习.

在 Spark 中几乎所有的transformation操作都是懒执行的(lazy), 也就是说transformation操作并不会立即计算他们的结果, 而是记住了这个操作.

只有当通过一个action来获取结果返回给驱动程序的时候这些转换操作才开始计算.

这种设计可以使 Spark 运行起来更加的高效.

默认情况下, 你每次在一个 RDD 上运行一个action的时候, 前面的每个transformed RDD 都会被重新计算.

但是我们可以通过persist (or cache)方法来持久化一个 RDD 在内存中, 也可以持久化到磁盘上, 来加快访问速度. 后面有专门的章节学习这种持久化技术.

根据 RDD 中数据类型的不同, 整体分为 2 种 RDD:

1. Value类型

2. Key-Value类型(其实就是存一个二维的元组)

#### 2.3.1 Value 类型

##### 2.3.1.1 map(func)

作用: 返回一个新的 RDD, 该 RDD 是由原 RDD 的每个元素经过函数转换后的值而组成. 就是对 RDD 中的数据做转换.

案例:

创建一个包含1-10的的 RDD，然后将每个元素*2形成新的 RDD

```scala
scala > val rdd1 = sc.parallelize(1 to 10)
rdd1: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[0] at parallelize at <console>:24
// 得到一个新的 RDD, 但是这个 RDD 中的元素并不是立即计算出来的
scala> val rdd2 = rdd1.map(_ * 2)
rdd2: org.apache.spark.rdd.RDD[Int] = MapPartitionsRDD[1] at map at
<console>:26

// 开始计算 rdd2 中的元素, 并把计算后的结果传递给驱动程序
scala> rdd2.collect
res0: Array[Int] = Array(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)
```

##### 2.3.1.2   mapPartitions(func)

作用: 类似于map(func), 但是是独立在每个分区上运行.所以:Iterator<T> => Iterator<U>

假设有N个元素，有M个分区，那么map的函数的将被调用N次,而mapPartitions被调用M次,一个函数一次处理所有分区。

```scala
scala> val source = sc.parallelize(1 to 10)
source: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[5] at parallelize at <console>:24

scala> source.mapPartitions(it => it.map(_ * 2))
res7: org.apache.spark.rdd.RDD[Int] = MapPartitionsRDD[6] at mapPartitions at <console>:27

scala> res7.collect
res8: Array[Int] = Array(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)
```

##### 2.3.1.3  mapPartitionsWithIndex(func)

作用: 和mapPartitions(func)类似. 但是会给func多提供一个Int值来表示分区的索引. 所以func的类型是:(Int, Iterator<T>) => Iterator<U>

```scala
scala> val rdd1 = sc.parallelize(Array(10,20,30,40,50,60))
rdd1: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[0] at parallelize at <console>:24

scala> rdd1.mapPartitionsWithIndex((index, items) => items.map((index, _)))
res8: org.apache.spark.rdd.RDD[(Int, Int)] = MapPartitionsRDD[3] at mapPartitionsWithIndex at <console>:27

scala> res8.collect
res9: Array[(Int, Int)] = Array((0,10), (0,20), (0,30), (1,40), (1,50), (1,60))
```

分区的确定，和对数组中的元素进行分区

1. 确定分区数

   ```scala
   override def defaultParallelism(): Int =
      scheduler.conf.getInt("spark.default.parallelism", totalCores)
   ```

2. 对元素进行分区

   ```scala
   // length: RDD 中数据的长度  numSlices: 分区数
   def positions(length: Long, numSlices: Int): Iterator[(Int, Int)] = {
    (0 until numSlices).iterator.map { i =>
      val start = ((i * length) / numSlices).toInt
      val end = (((i + 1) * length) / numSlices).toInt
      (start, end)
    }
   }
   seq match {
    case r: Range =>
      
    case nr: NumericRange[_] =>
      
    case _ =>
      val array = seq.toArray // To prevent O(n^2) operations for List etc
      positions(array.length, numSlices).map { case (start, end) =>
          array.slice(start, end).toSeq
      }.toSeq
   }
   ```

##### 2.3.1.4  map() 和 mapPartition() 的区别

1. map()： 每次处理一条数据
2. mapPartitions()：每次处理一个分区的数据，这个分区的数据处理完后，原RDD中该分区的数据才能释放，可能导致OMM
3. 开发指导：当内存空间较大的时候建议使用mapPartitions()，以提高处理效率

##### 2.3.1.5  flatmap(func)

作用: 类似于**map**，但是每一个输入元素可以被映射为 0 或多个输出元素（所以**func**应该返回一个序列，而不是单一元素 **T => TraversableOnce[U]**）

###### ***案例:***

创建一个元素为 1-5 的RDD，运用 **flatMap**创建一个新的 RDD，新的 RDD 为原 RDD 每个元素的 平方和三次方 来组成 **1,1,4,8,9,27..**

```scala
scala> val rdd1 = sc.parallelize(Array(1,2,3,4,5))
rdd1: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[5] at parallelize at <console>:24

scala> rdd1.flatMap(x => Array(x * x, x * x * x))
res13: org.apache.spark.rdd.RDD[Int] = MapPartitionsRDD[6] at flatMap at <console>:27

scala> res13.collect
res14: Array[Int] = Array(1, 1, 4, 8, 9, 27, 16, 64, 25, 125)
```

##### 2.3.1.6 glom()

作用: 将每一个分区的元素合并成一个数组，形成新的 RDD 类型是**RDD[Array[T]]**

###### ***案例***

创建一个 4 个分区的 RDD，并将每个分区的数据放到一个数组

```scala
scala> var rdd1 = sc.parallelize(Array(10,20,30,40,50,60), 4)
rdd1: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[0] at parallelize at <console>:24
scala> rdd1.glom.collect
res2: Array[Array[Int]] = Array(Array(10), Array(20, 30), Array(40), Array(50, 60))
```

##### 2.3.1.7 groupBy(func)

作用:

按照**func**的返回值进行分组.

**func**返回值作为 **key**, 对应的值放入一个迭代器中. 返回的 RDD: **RDD[(K, Iterable[T])**

每组内元素的顺序不能保证, 并且甚至每次调用得到的顺序也有可能不同.

***案例***

创建一个 RDD，按照元素的奇偶性进行分组

```scala
scala> val rdd1 = sc.makeRDD(Array(1, 3, 4, 20, 4, 5, 8))
rdd1: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[2] at makeRDD at <console>:24
    
scala> rdd1.groupBy(x => if(x % 2 == 1) "odd" else "even")
res4: org.apache.spark.rdd.RDD[(String, Iterable[Int])] = ShuffledRDD[4] at groupBy at <console>:27

scala> res4.collect
res5: Array[(String, Iterable[Int])] = Array((even,CompactBuffer(4, 20, 4, 8)), (odd,CompactBuffer(1, 3, 5)))
```

##### 2.3.1.8 filter(func)

作用: 过滤. 返回一个新的 RDD 是由**func**的返回值为**true**的那些元素组成

***案例***

创建一个 RDD（由字符串组成），过滤出一个新 RDD（包含“xiao”子串）

```scala
scala> val names = sc.parallelize(Array("xiaoli", "laoli", "laowang", "xiaocang", "xiaojing", "xiaokong"))
names: org.apache.spark.rdd.RDD[String] = ParallelCollectionRDD[0] at parallelize at <console>:24
    
scala> names.filter(_.contains("xiao"))
res3: org.apache.spark.rdd.RDD[String] = MapPartitionsRDD[1] at filter at <console>:27

scala> res3.collect
res4: Array[String] = Array(xiaoli, xiaocang, xiaojing, xiaokong) 
```

##### 2.3.1.9 sample(withReplacement,fraction,seed)

作用:

1. 以指定的随机种子随机抽样出比例为**fraction**的数据，(抽取到的数量是: **size \* fraction**). 需要注意的是得到的结果并不能保证准确的比例.

2. **withReplacement**表示是抽出的数据是否放回，**true**为有放回的抽样，**false**为无放回的抽样. 放回表示数据有可能会被重复抽取到, **false** 则不可能重复抽取到. 如果是**false**, 则**fraction**必须是:**[0,1]**, 是 **true** 则大于等于0就可以了.

3. **seed**用于指定随机数生成器种子。 一般用默认的, 或者传入当前的时间戳

* 不放回抽样

  ```scala
  scala> val rdd1 = sc.parallelize(1 to 10)
  rdd1: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[15] at parallelize at <console>:24
  
  scala> rdd1.sample(false, 0.5).collect
  res15: Array[Int] = Array(1, 3, 4, 7)
  ```

* 放回抽样

  ```scala
  scala> rdd1.sample(true, 2).collect
  res25: Array[Int] = Array(1, 1, 2, 3, 3, 4, 4, 5, 5, 5, 5, 5, 6, 6, 7, 7, 8, 8, 9)
  ```

#####  2.3.1.10 distinct([numTasks])

作用:

对 RDD 中元素执行去重操作. 参数表示任务的数量.默认值和分区数保持一致.

```scala
scala> val rdd1 = sc.parallelize(Array(10,10,2,5,3,5,3,6,9,1))
rdd1: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[28] at parallelize at <console>:24
    
scala> rdd1.distinct().collect
res29: Array[Int] = Array(6, 10, 2, 1, 3, 9, 5)
```

##### 2.3.1.11 coalesce(numPartitions)

作用: 缩减分区数到指定的数量，用于大数据集过滤后，提高小数据集的执行效率。

```scala
scala> val rdd1 = sc.parallelize(0 to 100, 5)
rdd1: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[45] at parallelize at <console>:24

scala> rdd1.partitions.length
res39: Int = 5

// 减少分区的数量至 2 
scala> rdd1.coalesce(2)
res40: org.apache.spark.rdd.RDD[Int] = CoalescedRDD[46] at coalesce at <console>:27

scala> res40.partitions.length
res41: Int = 2
```

注意：

第二个参数表示是否**shuffle**, 如果不传或者传入的为**false**, 则表示不进行**shuffer**, 此时分区数减少有效, 增加分区数无效.

##### 2.3.1.12 repartition(numPatitions)

作用: 根据新的分区数, 重新 shuffle 所有的数据, 这个操作总会通过网络.

新的分区数相比以前可以多, 也可以少

```scala
scala> val rdd1 = sc.parallelize(0 to 100, 5)
rdd1: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[45] at parallelize at <console>:24

scala> rdd1.repartition(3)
res44: org.apache.spark.rdd.RDD[Int] = MapPartitionsRDD[51] at repartition at <console>:27

scala> res44.partitions.length
res45: Int = 3

scala> rdd1.repartition(10)
res46: org.apache.spark.rdd.RDD[Int] = MapPartitionsRDD[55] at repartition at <console>:27

scala> res46.partitions.length
res47: Int = 10
```

##### 2.3.1.13 coalasce 和 repartition 的区别

1. coalesce 重新分区，可以选择是否进行shuffle 过程。由参数shuffle：Boolean=false/true 决定

2. repartiton 实际上是调用的coalesce，进行shuffle。源码如下：

   ```scala
   def repartition(numPartitions: Int)(implicit ord: Ordering[T] = null): RDD[T] = withScope {
   coalesce(numPartitions, shuffle = true)
   }
   ```

3. 如果是减少分区, 尽量避免 shuffle

##### 2.3.1.14 sortBy(func,[ascending],[numTasks])

作用: 使用**func**先对数据进行处理，按照处理后结果排序，默认为正序

```scala
scala> val rdd1 = sc.parallelize(Array(1,3,4,10,4,6,9,20,30,16))
rdd1: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[46] at parallelize at <console>:24

scala> rdd1.sortBy(x => x).collect
res17: Array[Int] = Array(1, 3, 4, 4, 6, 9, 10, 16, 20, 30)

scala> rdd1.sortBy(x => x, true).collect
res18: Array[Int] = Array(1, 3, 4, 4, 6, 9, 10, 16, 20, 30)
// 不用正序
scala> rdd1.sortBy(x => x, false).collect
res19: Array[Int] = Array(30, 20, 16, 10, 9, 6, 4, 4, 3, 1)
```

##### 2.3.1.15 pipe(command,[envVars])

作用: 管道，针对每个分区，把 RDD 中的每个数据通过管道传递给**shell**命令或脚本，返回输出的RDD。一个分区执行一次这个命令. 如果只有一个分区, 则执行一次命令.

注意:

脚本要放在 worker 节点可以访问到的位置

**步骤 1：创建一个脚本文件pipe.sh**

文件内容如下:

```shell
echo "hello"
while read line;do
    echo ">>>"$line
done
```

**步骤2：创建只有1个分区的RDD**

```scala
scala> val rdd1 = sc.parallelize(Array(10,20,30,40), 1)
rdd1: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[0] at parallelize at <console>:24

scala> rdd1.pipe("./pipe.sh").collect
res1: Array[String] = Array(hello, >>>10, >>>20, >>>30, >>>40)
```

**步骤3：建有 2个分区的RDD**

```scala
scala> val rdd1 = sc.parallelize(Array(10,20,30,40), 2)
rdd1: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[3] at parallelize at <console>:24

scala> rdd1.pipe("./pipe.sh").collect
res2: Array[String] = Array(hello, >>>10, >>>20, hello, >>>30, >>>40)
```

###### **总结: 每个分区执行一次脚本, 但是每个元素算是标准输入中的一行**

#### 2.3.2  双Value 类型交互

这里的“双 **Value** 类型交互”是指的两个 **RDD[V]** 进行交互.

##### 2.3.2.1 union(otherDataSet)

作用：求并集. 对源 RDD 和参数 RDD 求并集后返回一个新的 RDD

**案例**

需求: 创建两个RDD，求并集

```scala
scala> val rdd1 = sc.parallelize(1 to 6)
rdd1: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[2] at parallelize at <console>:24
scala> val rdd2 = sc.parallelize(4 to 10)
rdd2: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[3] at parallelize at <console>:24
scala> rdd1.union(rdd2)
res0: org.apache.spark.rdd.RDD[Int] = UnionRDD[4] at union at <console>:29

scala> res0.collect
res1: Array[Int] = Array(1, 2, 3, 4, 5, 6, 4, 5, 6, 7, 8, 9, 10)
```

注意:

**union**和**++**是等价的

##### 2.3.2.2 substract(otherDataset)

作用: 计算差集. 从原 RDD 中减去 原 RDD 和 otherDataset 中的共同的部分.

```scala
scala> rdd1.subtract(rdd2).collect
res4: Array[Int] = Array(2, 1, 3)

scala> rdd2.subtract(rdd1).collect
res5: Array[Int] = Array(8, 10, 7, 9)
```

##### 2.3.2.3 intersection(otherDataset)

作用: 计算交集. 对源 RDD 和参数 RDD 求交集后返回一个新的 RDD

```scala
scala> rdd1.intersection(rdd2).collect
res8: Array[Int] = Array(4, 6, 5)
```

##### 2.3.2.4 cartesian(otherDataset)

作用: 计算 2 个 RDD 的笛卡尔积. 尽量避免使用

```scala
scala> rdd1.cartesian(rdd2).collect
res11: Array[(Int, Int)] = Array((1,4), (1,5), (1,6), (2,4), (2,5), (2,6), (3,4), (3,5), (3,6), (1,7), (1,8), (1,9), (1,10), (2,7), (2,8), (2,9), (2,10), (3,7), (3,8), (3,9), (3,10), (4,4), (4,5), (4,6), (5,4), (5,5), (5,6), (6,4), (6,5), (6,6), (4,7), (4,8), (4,9), (4,10), (5,7), (5,8), (5,9), (5,10), (6,7), (6,8), (6,9), (6,10))
```

##### 2.3.2.5 zip(otherDataSet)

作用: 拉链操作. 需要注意的是, 在 Spark 中, 两个 RDD 的元素的数量和分区数都必须相同, 否则会抛出异常.(在 scala 中, 两个集合的长度可以不同)

其实本质就是要求的每个分区的元素的数量相同.

```scala
scala> val rdd1 = sc.parallelize(1 to 5)
rdd1: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[34] at parallelize at <console>:24

scala> val rdd2 = sc.parallelize(11 to 15)
rdd2: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[35] at parallelize at <console>:24

scala> rdd1.zip(rdd2).collect
res17: Array[(Int, Int)] = Array((1,11), (2,12), (3,13), (4,14), (5,15))
```

类似算子: zipWithIndex, zipPartitions

#### 2.3.3 Key-Value 类型

大多数的 Spark 操作可以用在任意类型的 RDD 上, 但是有一些比较特殊的操作只能用在**key-value**类型的 RDD 上.

这些特殊操作大多都涉及到 shuffle 操作, 比如: 按照 key 分组(group), 聚集(aggregate)等.

在 Spark 中, 这些操作在包含对偶类型(**Tuple2**)的 RDD 上自动可用(通过隐式转换).

```scala
object RDD {
  implicit def rddToPairRDDFunctions[K, V](rdd: RDD[(K, V)])
    (implicit kt: ClassTag[K], vt: ClassTag[V], ord: Ordering[K] = null): PairRDDFunctions[K, V] = {
    new PairRDDFunctions(rdd)
  }
```

键值对的操作是定义在**PairRDDFunctions**类上, 这个类是对**RDD[(K, V)]**的装饰.

##### 2.3.3.1 partitionBy

作用: 对 pairRDD 进行分区操作，如果原有的 partionRDD 的分区器和传入的分区器相同, 则返回原 pairRDD，否则会生成 ShuffleRDD，即会产生 **shuffle** 过程。

partitionBy 算子源码

```scala
def partitionBy(partitioner: Partitioner): RDD[(K, V)] = self.withScope {
  
  if (self.partitioner == Some(partitioner)) {
    self
  } else {
    new ShuffledRDD[K, V, V](self, partitioner)
  }
}
scala> val rdd1 = sc.parallelize(Array((1, "a"), (2, "b"), (3, "c"), (4, "d")))
rdd1: org.apache.spark.rdd.RDD[(Int, String)] = ParallelCollectionRDD[0] at parallelize at <console>:24

scala> rdd1.partitions.length
res1: Int = 2

scala> rdd1.partitionBy(new org.apache.spark.HashPartitioner(3)).partitions.length
res3: Int = 3
```

##### 2.3.3.2 reduceByKey(func,[numTasks])

作用: 在一个**(K,V)**的 RDD 上调用，返回一个**(K,V)**的 RDD，使用指定的**reduce**函数，将相同**key**的**value**聚合到一起，**reduce**任务的个数可以通过第二个可选的参数来设置。

```scala
scala> val rdd1 = sc.parallelize(List(("female",1),("male",5),("female",5),("male",2)))
rdd1: org.apache.spark.rdd.RDD[(String, Int)] = ParallelCollectionRDD[0] at parallelize at <console>:24

scala> rdd1.reduceByKey(_ + _)
res1: org.apache.spark.rdd.RDD[(String, Int)] = ShuffledRDD[1] at reduceByKey at <console>:27

scala> res1.collect
res2: Array[(String, Int)] = Array((female,6), (male,7))
```

##### 2.3.3.3 groupByKey()

作用: 按照**key**进行分组.

```scala
scala> val rdd1 = sc.parallelize(Array("hello", "world", "atguigu", "hello", "are", "go"))
rdd1: org.apache.spark.rdd.RDD[String] = ParallelCollectionRDD[2] at parallelize at <console>:24

scala> val rdd2 = rdd1.map((_, 1))
rdd2: org.apache.spark.rdd.RDD[(String, Int)] = MapPartitionsRDD[3] at map at <console>:26

scala> rdd2.groupByKey()
res3: org.apache.spark.rdd.RDD[(String, Iterable[Int])] = ShuffledRDD[4] at groupByKey at <console>:29

scala> res3.collect
res4: Array[(String, Iterable[Int])] = Array((are,CompactBuffer(1)), (hello,CompactBuffer(1, 1)), (go,CompactBuffer(1)), (atguigu,CompactBuffer(1)), (world,CompactBuffer(1)))

scala> res3.map(t => (t._1, t._2.sum))
res5: org.apache.spark.rdd.RDD[(String, Int)] = MapPartitionsRDD[5] at map at <console>:31
                
scala> res5.collect
res7: Array[(String, Int)] = Array((are,1), (hello,2), (go,1), (atguigu,1), (world,1))
```

注意：

1. 基于当前的实现，groupByKey 必须在内存中持有所有的键值对。如果一个key 有太多的value，则会导致内存的溢出
2. 所以这操作非常耗资源，如果分组的目的就是为了在每个key上执行行聚合操作(比如: **sum** 和 **average**), 则应该使用**PairRDDFunctions.aggregateByKey** 或者 **PairRDDFunctions.reduceByKey** ,因为他们有更好的性能(会先在分区进行预聚合)

##### 2.3.3.4 reduceByKey 和 groupByKey 的区别

1. reduceByKey： 按照**key**进行聚合，在**shuffle**之前有**combine**（预聚合）操作，返回结果是**RDD[k,v]**。
2. **groupByKey**：按照**key**进行分组，直接进行**shuffle**。
3. 开发指导：r**educeByKey**比**groupByKey**性能更好，建议使用。但是需要注意是否会影响业务逻辑。

##### 2.3.3.5 aggregateByKey(zeroValue)(seqOp,combOp,[numTasks])

函数声明:

```scala
def aggregateByKey[U: ClassTag](zeroValue: U)(seqOp: (U, V) => U,
                                              combOp: (U, U) => U): RDD[(K, U)] = self.withScope {
    aggregateByKey(zeroValue, defaultPartitioner(self))(seqOp, combOp)
}
```

使用给定的 combine 函数和一个初始化的**zero value**, 对每个**key**的**value**进行聚合.

这个函数返回的类型**U**不同于源 RDD 中的**V**类型. **U**的类型是由初始化的**zero value**来定的. 所以, 我们需要两个操作: - 一个操作(**seqOp**)去把 1 个**v**变成 1 个**U** - 另外一个操作(**combOp**)来合并 2 个**U**

第一个操作用于在一个分区进行合并, 第二个操作用在两个分区间进行合并.

为了避免内存分配, 这两个操作函数都允许返回第一个参数, 而不用创建一个新的**U**

参数描述:

1. **zeroValue**：给每一个分区中的每一个**key**一个初始值；
2. **seqOp：**函数用于在每一个分区中用初始值逐步迭代**value**；
3. **combOp：**函数用于合并每个分区中的结果。

**案例**

需求: 创建一个 pairRDD，取出每个分区相同**key**对应值的最大值，然后相加

```scala
scala> val rdd = sc.parallelize(List(("a",3),("a",2),("c",4),("b",3),("c",6),("c",8)),2)
rdd: org.apache.spark.rdd.RDD[(String, Int)] = ParallelCollectionRDD[0] at parallelize at <console>:24
scala> rdd.aggregateByKey(Int.MinValue)(math.max(_, _), _ +_)
res0: org.apache.spark.rdd.RDD[(String, Int)] = ShuffledRDD[1] at aggregateByKey at <console>:27

scala> res0.collect
res1: Array[(String, Int)] = Array((b,3), (a,3), (c,12)) 
```

##### 2.3.3.6 foldByKey

参数: **(zeroValue: V)(func: (V, V) => V): RDD[(K, V)]**

作用：**aggregateByKey**的简化操作，**seqop**和**combop**相同

```scala
scala> val rdd = sc.parallelize(Array(("a",3), ("a",2), ("c",4), ("b",3), ("c",6), ("c",8)))
rdd: org.apache.spark.rdd.RDD[(String, Int)] = ParallelCollectionRDD[2] at parallelize at <console>:24

scala> rdd.foldByKey(0)(_ + _).collect
res5: Array[(String, Int)] = Array((b,3), (a,5), (c,18))
```

##### 2.3.3.7 combineByKey[C]

函数声明:

```scala
def combineByKey[C](
                       createCombiner: V => C,
                       mergeValue: (C, V) => C,
                       mergeCombiners: (C, C) => C): RDD[(K, C)] = self.withScope {
    combineByKeyWithClassTag(createCombiner, mergeValue, mergeCombiners,
        partitioner, mapSideCombine, serializer)(null)
}
```

1. 作用: 针对每个**K**, 将**V**进行合并成**C**, 得到**RDD[(K,C)]**
2. 参数描述:
3. **createCombiner:** **combineByKey**会遍历分区中的每个**key-value**对. 如果第一次碰到这个**key**, 则调用**createCombiner**函数,传入**value**, 得到一个**C**类型的值.(如果不是第一次碰到这个 key, 则不会调用这个方法)
4. **mergeValue:** 如果不是第一个遇到这个**key**, 则调用这个函数进行合并操作. 分区内合并
5. **mergeCombiners** 跨分区合并相同的**key**的值(**C**). 跨分区合并

**案例**

需求1: 创建一个 **pairRDD**，根据 **key** 计算每种 **key** 的**value**的平均值。（先计算每个key出现的次数以及可以对应值的总和，再相除得到结果）

```scala
scala> val input = sc.parallelize(Array(("a", 88), ("b", 95), ("a", 91), ("b", 93), ("a", 95), ("b", 98)),2)
input: org.apache.spark.rdd.RDD[(String, Int)] = ParallelCollectionRDD[5] at parallelize at <console>:24
// acc 累加器, 用来记录分区内的值的和这个 key 出现的次数
// acc1, acc2 跨分区的累加器
scala> input.combineByKey((_, 1), (acc:(Int, Int), v) => (acc._1 + v, acc._2 + 1), (acc1:(Int, Int), acc2: (Int, Int))=> (acc1._1 + acc2._1, acc1._2 + acc2._2))
res10: org.apache.spark.rdd.RDD[(String, (Int, Int))] = ShuffledRDD[7] at combineByKey at <console>:27

scala> res10.collect
res11: Array[(String, (Int, Int))] = Array((b,(286,3)), (a,(274,3)))

scala> res10.map(t => (t._1, t._2._1.toDouble / t._2._2)).collect
res12: Array[(String, Double)] = Array((b,95.33333333333333), (a,91.33333333333333))
```

##### 2.3.3.8 sortByKey

作用: 在一个**(K,V)**的 RDD 上调用, **K**必须实现 **Ordered[K]** 接口(或者有一个隐式值: **Ordering[K]**), 返回一个按照**key**进行排序的**(K,V)**的 RDD

```scala
scala> val rdd = sc.parallelize(Array((1, "a"), (10, "b"), (11, "c"), (4, "d"), (20, "d"), (10, "e")))
rdd: org.apache.spark.rdd.RDD[(Int, String)] = ParallelCollectionRDD[11] at parallelize at <console>:24

scala> rdd.sortByKey()
res25: org.apache.spark.rdd.RDD[(Int, String)] = ShuffledRDD[14] at sortByKey at <console>:27

scala> res25.collect
res26: Array[(Int, String)] = Array((1,a), (4,d), (10,b), (10,e), (11,c), (20,d))

scala> rdd.sortByKey(true).collect
res27: Array[(Int, String)] = Array((1,a), (4,d), (10,b), (10,e), (11,c), (20,d))

// 倒序
scala> rdd.sortByKey(false).collect
res28: Array[(Int, String)] = Array((20,d), (11,c), (10,b), (10,e), (4,d), (1,a))
```

##### 2.3.3.9 mapValues

作用: 针对**(K,V)**形式的类型只对**V**进行操作

```scala
scala> val rdd = sc.parallelize(Array((1, "a"), (10, "b"), (11, "c"), (4, "d"), (20, "d"), (10, "e")))
rdd: org.apache.spark.rdd.RDD[(Int, String)] = ParallelCollectionRDD[21] at parallelize at <console>:24

scala> rdd.mapValues("<" + _ + ">").collect
res29: Array[(Int, String)] = Array((1,<a>), (10,<b>), (11,<c>), (4,<d>), (20,<d>), (10,<e>))
```

##### 2.3.3.10 join(otherDataset, [numTasks])

内连接:

在类型为**(K,V)**和**(K,W)**的 RDD 上调用，返回一个相同 key 对应的所有元素对在一起的**(K,(V,W))**的RDD

```scala
scala> var rdd1 = sc.parallelize(Array((1, "a"), (1, "b"), (2, "c")))
rdd1: org.apache.spark.rdd.RDD[(Int, String)] = ParallelCollectionRDD[6] at parallelize at <console>:24

scala> var rdd2 = sc.parallelize(Array((1, "aa"), (3, "bb"), (2, "cc")))
rdd2: org.apache.spark.rdd.RDD[(Int, String)] = ParallelCollectionRDD[7] at parallelize at <console>:24

scala> rdd1.join(rdd2).collect
res2: Array[(Int, (String, String))] = Array((2,(c,cc)), (1,(a,aa)), (1,(b,aa)))
```

注意:

1. 如果某一个 RDD 有重复的 **Key**, 则会分别与另外一个 RDD 的相同的 **Key**进行组合.
2. 也支持外连接: **leftOuterJoin, rightOuterJoin, and fullOuterJoin.**

##### 2.3.3.11 cogroup(otherDataset,[numTasks])

作用：在类型为**(K,V)**和**(K,W)**的 RDD 上调用，返回一个**(K,(Iterable<V>,Iterable<W>))**类型的 RDD

```scala
scala> val rdd1 = sc.parallelize(Array((1, 10),(2, 20),(1, 100),(3, 30)),1)
rdd1: org.apache.spark.rdd.RDD[(Int, Int)] = ParallelCollectionRDD[23] at parallelize at <console>:24

scala> val rdd2 = sc.parallelize(Array((1, "a"),(2, "b"),(1, "aa"),(3, "c")),1)
rdd2: org.apache.spark.rdd.RDD[(Int, String)] = ParallelCollectionRDD[24] at parallelize at <console>:24

scala> rdd1.cogroup(rdd2).collect
res9: Array[(Int, (Iterable[Int], Iterable[String]))] = Array((1,(CompactBuffer(10, 100),CompactBuffer(a, aa))), (3,(CompactBuffer(30),CompactBuffer(c))), (2,(CompactBuffer(20),CompactBuffer(b))))
```

#### 2.3.4 案例实操

**需求**

1. 数据结构：时间戳，省份，城市，用户，广告，字段使用空格分割。

   ```txt
   1516609143867 6 7 64 16
   1516609143869 9 4 75 18
   1516609143869 1 7 87 12
   ```

2. 需求: 统计出每一个省份广告被点击次数的 TOP3

**具体实现 **

**步骤1:把文件放入到resources目录下**

**步骤2:具体代码**

```scala
package day03

/*
数据结构：时间戳，省份，城市，用户，广告 字段使用空格分割。

样本如下：
1516609143867 6 7 64 16
1516609143869 9 4 75 18
1516609143869 1 7 87 12

统计出每一个省份广告被点击次数的 TOP3
*/
object Practice {
    def main(args: Array[String]): Unit = {
        // 1. 初始化spark配置信息, 并建立到spark的连接
        val conf = new SparkConf().setAppName("Practice").setMaster("local[*]")
        val sc = new SparkContext(conf)
        // 2. 从文件中读取数据, 得到 RDD. RDD中存储的是文件的中的每行数据
        val lines: RDD[String] = sc.textFile("file://" + ClassLoader.getSystemResource("agent.log"))

        // 3. ((provice, ad), 1)
        val provinceADAndOne: RDD[((String, String), Int)] = lines.map(line => {
            val splits: Array[String] = line.split(" ")
            ((splits(1), splits(4)), 1)
        })
        // 4. 计算每个省份每个广告被点击的总次数
        val provinceADSum: RDD[((String, String), Int)] = provinceADAndOne.reduceByKey(_ + _)

        // 5. 将省份作为key，广告加点击数为value： (Province,(AD,sum))
        val provinceToAdSum: RDD[(String, (String, Int))] = provinceADSum.map(x => (x._1._1, (x._1._2, x._2)))

        // 6. 按照省份进行分组
        val provinceGroup: RDD[(String, Iterable[(String, Int)])] = provinceToAdSum.groupByKey()

        //7. 对同一个省份的广告进行排序, 按照点击数的降序
        val result: RDD[(String, List[(String, Int)])] = provinceGroup.mapValues {
            x => x.toList.sortBy(_._2)(Ordering.Int.reverse).take(3)
        }

        //8. 按照省份的升序展示最终结果
        result.sortBy(_._1).collect.foreach(println)

        // 9. 关闭连接
        sc.stop()

    }
}
```

![结果](https://gitee.com/zhdoop/blogImg/raw/master/img/RDD-result.png)

使用倒推法

```
=> [((pid, cid), 1), ((pid, cid), 1)]   reuceByKey
=> [(pid, cid), count), (pid, cid), count]  map
=> [pid, (cid, count), (cid, count)]  groupByKey
=> [pid, Iterable((cid, count), (cid, count), ...)]
```

### 2.4 RDD的 Action 操作

#### 2.4.1 reduce(func)

通过**func**函数聚集 RDD 中的所有元素，先聚合分区内数据，再聚合分区间数据。

```scala
scala> val rdd1 = sc.parallelize(1 to 100)
rdd1: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[0] at parallelize at <console>:24

scala> rdd1.reduce(_ + _)
res0: Int = 5050

scala> val rdd2 = sc.parallelize(Array(("a", 1), ("b", 2), ("c", 3)))
rdd2: org.apache.spark.rdd.RDD[(String, Int)] = ParallelCollectionRDD[1] at parallelize at <console>:24

scala> rdd2.reduce((x, y) => (x._1 + y._1, x._2 + y._2))
res2: (String, Int) = (abc,6)
```

#### 2.4.2 collect

以数组的形式返回 RDD 中的所有元素.所有的数据都会被拉到 driver 端, 所以要慎用

#### 2.4.3 count()

返回 RDD 中元素的个数.

#### 2.4.4 take(n)

返回 RDD 中前 n 个元素组成的数组.

take 的数据也会拉到 driver 端, 应该只对小数据集使用

```scala
scala> val rdd1 = sc.makeRDD(Array(10, 20, 30, 50, 60))
rdd1: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[2] at makeRDD at <console>:24

scala> rdd1.take(2)
res3: Array[Int] = Array(10, 20)
```

#### 2.4.5 first

返回 RDD 中的第一个元素. 类似于**take(1)**.

#### 2.4.6 takeOrdered(n, [ordering])

返回排序后的前 **n** 个元素, 默认是升序排列.

数据也会拉到 driver 端

```scala
scala> val rdd1 = sc.makeRDD(Array(100, 20, 130, 500, 60))
rdd1: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[4] at makeRDD at <console>:24

scala> rdd1.takeOrdered(2)
res6: Array[Int] = Array(20, 60)
    
scala> rdd1.takeOrdered(2)(Ordering.Int.reverse)
res7: Array[Int] = Array(500, 130)
```

#### 2.4.7 aggregate

```scala
def aggregate[U: ClassTag](zeroValue: U)(seqOp: (U, T) => U, combOp: (U, U) => U): U
```

**aggregate**函数将每个分区里面的元素通过**seqOp**和初始值进行聚合，然后用**combine**函数将每个分区的结果和初始值(**zeroValue**)进行**combine**操作。这个函数最终返回的类型不需要和RDD中元素类型一致

注意:**zeroValue** 分区内聚合和分区间聚合的时候各会使用一次

```scala
scala> val rdd1 = sc.makeRDD(Array(100, 30, 10, 30, 1, 50, 1, 60, 1), 2)
rdd1: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[8] at makeRDD at <console>:24

scala> rdd1.aggregate(0)(_ + _, _ + _)
res12: Int = 283

scala> val rdd1 = sc.makeRDD(Array("a", "b", "c", "d"), 2)
rdd1: org.apache.spark.rdd.RDD[String] = ParallelCollectionRDD[9] at makeRDD at <console>:24

scala> rdd1.aggregate("x")(_ + _, _ + _)
res13: String = xxabxcd
```

####  2.4.8 fold

折叠操作，**aggregate**的简化操作，**seqop**和**combop**一样的时候,可以使用**fold**

```scala
scala> val rdd1 = sc.makeRDD(Array(100, 30, 10, 30, 1, 50, 1, 60, 1), 2)
rdd1: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[10] at makeRDD at <console>:24

scala> rdd1.fold(0)(_ + _)
res16: Int = 283

scala> val rdd1 = sc.makeRDD(Array("a", "b", "c", "d"), 2)
rdd1: org.apache.spark.rdd.RDD[String] = ParallelCollectionRDD[11] at makeRDD at <console>:24

scala> rdd1.fold("x")(_ + _)
res17: String = xxabxcd                           
```

#### 2.4.9 saveAsTextFile(path)

作用：将数据集的元素以**textfile**的形式保存到**HDFS**文件系统或者其他支持的文件系统，对于每个元素，Spark 将会调用**toString**方法，将它装换为文件中的文本

#### 2.4.10 saveAsSequenceFile(path)

作用：将数据集中的元素以 Hadoop sequencefile 的格式保存到指定的目录下，可以使 HDFS 或者其他 Hadoop 支持的文件系统。

#### 2.4.11 saveAsObjectFile(path)

作用：用于将 RDD 中的元素序列化成对象，存储到文件中。

#### 2.4.12 countByKey()

作用：针对**(K,V)**类型的 RDD，返回一个**(K,Int)**的**map**，表示每一个**key**对应的元素个数。

应用: 可以用来查看数据是否倾斜

```scala
scala> val rdd1 = sc.parallelize(Array(("a", 10), ("a", 20), ("b", 100), ("c", 200)))
rdd1: org.apache.spark.rdd.RDD[(String, Int)] = ParallelCollectionRDD[15] at parallelize at <console>:24

scala> rdd1.countByKey()
res19: scala.collection.Map[String,Long] = Map(b -> 1, a -> 2, c -> 1)
```

#### 2.4.13 foreach(func)

作用: 针对 RDD 中的每个元素都执行一次**func**每个函数是在 Executor 上执行的, 不是在 driver 端执行的.

### 2.5 RDD 中函数的传递

我们进行 Spark 进行编程的时候, 初始化工作是在 **driver**端完成的, 而实际的运行程序是在**executor**端进行的. 所以就涉及到了进程间的通讯, 数据是需要序列化的.

#### 2.5.1 传递函数

```scala
package day03

import org.apache.spark.{SparkConf, SparkContext}
import org.apache.spark.rdd.RDD

object SerDemo {
    def main(args: Array[String]): Unit = {
        val conf: SparkConf = new SparkConf().setAppName("SerDemo").setMaster("local[*]")
        val sc = new SparkContext(conf)
        val rdd: RDD[String] = sc.parallelize(Array("hello world", "hello atguigu", "atguigu", "hahah"), 2)
        val searcher = new Searcher("hello")
        val result: RDD[String] = searcher.getMatchedRDD1(rdd)
        result.collect.foreach(println)
    }
}
//需求: 在 RDD 中查找出来包含 query 子字符串的元素

// query 为需要查找的子字符串
class Searcher(val query: String){
    // 判断 s 中是否包括子字符串 query
    def isMatch(s : String) ={
        s.contains(query)
    }
    // 过滤出包含 query字符串的字符串组成的新的 RDD
    def getMatchedRDD1(rdd: RDD[String]) ={
        rdd.filter(isMatch)  //
    }
    // 过滤出包含 query字符串的字符串组成的新的 RDD
    def getMatchedRDD2(rdd: RDD[String]) ={
        rdd.filter(_.contains(query))
    }
}
```

说明:

 直接运行程序会发现报错: 没有初始化. 因为**rdd.filter(isMatch)** 用到了对象**this**的方法**isMatch**, 所以对象**this**需要序列化,才能把对象从**driver**发送到**executor**.

![序列化错误](https://gitee.com/zhdoop/blogImg/raw/master/img/serializable-error.png)

解决方案: 让 **Searcher** 类实现序列化接口:**Serializable**

#### 2.5.2 传递变量

```scala
object SerDemo {
    def main(args: Array[String]): Unit = {
        val conf: SparkConf = new SparkConf().setAppName("SerDemo").setMaster("local[*]")
        val sc = new SparkContext(conf)
        val rdd: RDD[String] = sc.parallelize(Array("hello world", "hello atguigu", "atguigu", "hahah"), 2)
        val searcher = new Searcher("hello")
        val result: RDD[String] = searcher.getMatchedRDD2(rdd)
        result.collect.foreach(println)
    }
}
```

说明：

1. 这次没有传递函数, 而是传递了一个属性过去. 仍然会报错没有序列化. 因为**this**仍然没有序列化.

2. 解决方案有 2 种:

3. 让类实现序列化接口:**Serializable**

4. 传递局部变量而不是属性.

```scala
 def getMatchedRDD2(rdd: RDD[String]) ={
     	val q = query
        rdd.filter(_.contains(q))
    }
```

#### 2.5.3 kryo 序列化框架

参考地址: https://github.com/EsotericSoftware/kryo

Java 的序列化比较重, 能够序列化任何的类. 比较灵活,但是相当的慢, 并且序列化后对象的体积也比较大.

Spark 出于性能的考虑, 支持另外一种序列化机制: kryo (2.0开始支持). kryo 比较快和简洁.(速度是**Serializable**的10倍). 想获取更好的性能应该使用 kryo 来序列化.

从2.0开始, Spark 内部已经在使用 kryo 序列化机制: 当 RDD 在 **Shuffle**数据的时候, 简单数据类型, 简单数据类型的数组和字符串类型已经在使用 kryo 来序列化.

有一点需要注意的是: 即使使用 kryo 序列化, 也要继承 **Serializable** 接口

```scala
package day03

import org.apache.spark.{SparkConf, SparkContext}
import org.apache.spark.rdd.RDD


object SerDemo {
    def main(args: Array[String]): Unit = {
        val conf: SparkConf = new SparkConf()
            .setAppName("SerDemo")
            .setMaster("local[*]")
            // 替换默认的序列化机制 可以省(如果调用registerKryoClasses
            .set("spark.serializer", "org.apache.spark.serializer.KryoSerializer")
            // 注册需要使用 kryo 序列化的自定义类
            .registerKryoClasses(Array(classOf[Searcher]))
        val sc = new SparkContext(conf)
        val rdd: RDD[String] = sc.parallelize(Array("hello world", "hello atguigu", "atguigu", "hahah"), 2)
        val searcher = new Searcher("hello")
        val result: RDD[String] = searcher.getMatchedRDD1(rdd)
        result.collect.foreach(println)
    }
}

case class Searcher(val query: String) {
    // 判断 s 中是否包括子字符串 query
    def isMatch(s: String) = {
        s.contains(query)
    }


    // 过滤出包含 query字符串的字符串组成的新的 RDD
    def getMatchedRDD1(rdd: RDD[String]) = {
        rdd.filter(isMatch) //
    }

    // 过滤出包含 query字符串的字符串组成的新的 RDD
    def getMatchedRDD2(rdd: RDD[String]) = {
        val q = query
        rdd.filter(_.contains(q))
    }
}
```

### 2.6 RDD 的依赖关系

```scala
scala> var rdd1 = sc.textFile("./words.txt")
rdd1: org.apache.spark.rdd.RDD[String] = ./words.txt MapPartitionsRDD[16] at textFile at <console>:24

scala> val rdd2 = rdd1.flatMap(_.split(" "))
rdd2: org.apache.spark.rdd.RDD[String] = MapPartitionsRDD[17] at flatMap at <console>:26

scala> val rdd3 = rdd2.map((_, 1))
rdd3: org.apache.spark.rdd.RDD[(String, Int)] = MapPartitionsRDD[18] at map at <console>:28

scala> val rdd4 = rdd3.reduceByKey(_ + _)
rdd4: org.apache.spark.rdd.RDD[(String, Int)] = ShuffledRDD[19] at reduceByKey at <console>:30
```

#### 2.6.1 查看 RDD 的血缘关系

```scala
scala> rdd1.toDebugString
res1: String =
(2) ./words.txt MapPartitionsRDD[1] at textFile at <console>:24 []
| ./words.txt HadoopRDD[0] at textFile at <console>:24 []

scala> rdd2.toDebugString
res2: String =
(2) MapPartitionsRDD[2] at flatMap at <console>:26 []
| ./words.txt MapPartitionsRDD[1] at textFile at <console>:24 []
| ./words.txt HadoopRDD[0] at textFile at <console>:24 []

scala> rdd3.toDebugString
res3: String =
(2) MapPartitionsRDD[3] at map at <console>:28 []
| MapPartitionsRDD[2] at flatMap at <console>:26 []
| ./words.txt MapPartitionsRDD[1] at textFile at <console>:24 []
| ./words.txt HadoopRDD[0] at textFile at <console>:24 []

scala> rdd4.toDebugString
res4: String =
(2) ShuffledRDD[4] at reduceByKey at <console>:30 []
+-(2) MapPartitionsRDD[3] at map at <console>:28 []
| MapPartitionsRDD[2] at flatMap at <console>:26 []
| ./words.txt MapPartitionsRDD[1] at textFile at <console>:24 []
| ./words.txt HadoopRDD[0] at textFile at <console>:24 []
```

说明:圆括号中的数字表示 RDD 的并行度. 也就是有几个分区.

#### 2.6.2 查看RDD的依赖关系

```scala
scala> rdd1.dependencies
res28: Seq[org.apache.spark.Dependency[_]] = List(org.apache.spark.OneToOneDependency@70dbde75)

scala> rdd2.dependencies
res29: Seq[org.apache.spark.Dependency[_]] = List(org.apache.spark.OneToOneDependency@21a87972)

scala> rdd3.dependencies
res30: Seq[org.apache.spark.Dependency[_]] = List(org.apache.spark.OneToOneDependency@4776f6af)

scala> rdd4.dependencies
res31: Seq[org.apache.spark.Dependency[_]] = List(org.apache.spark.ShuffleDependency@4809035f)
```

想理解 RDDs 是如何工作的, 最重要的事情就是了解 transformations.

RDD 之间的关系可以从两个维度来理解: 一个是 RDD 是从哪些 RDD 转换而来, 也就是 RDD 的 parent RDD(s)是什么; 另一个就是 RDD 依赖于 parent RDD(s)的哪些 Partition(s). 这种关系就是 RDD 之间的依赖.

依赖 有 2 种策略:

1. 窄依赖(transformations with narrow dependencies)

2. 宽依赖(transformations with wide dependencies)

宽依赖对 Spark 去评估一个 transformations 有更加重要的影响, 比如对性能的影响.

####  2.6.3 窄依赖

如果 B RDD 是由 A RDD 计算得到的, 则 B RDD 就是 Child RDD, A RDD 就是 parent RDD.

如果依赖关系在设计的时候就可以确定, 而不需要考虑父 RDD 分区中的记录, 并且如果父 RDD 中的每个分区最多只有一个子分区, 这样的依赖就叫窄依赖

一句话总结: 父 RDD 的每个分区最多被一个 RDD 的分区使用

![窄依赖](https://gitee.com/zhdoop/blogImg/raw/master/img/窄依赖.png)

具体来说, 窄依赖的时候, 子 RDD 中的分区要么只依赖一个父 RDD 中的一个分区(比如**map**, **filter**操作), 要么在设计时候就能确定子 RDD 是父 RDD 的一个子集(比如: **coalesce**).

所以, 窄依赖的转换可以在任何的的一个分区上单独执行, 而不需要其他分区的任何信息.

#### 2.6.4 宽依赖

如果 父 RDD 的分区被不止一个子 RDD 的分区依赖, 就是宽依赖.

![宽依赖](https://gitee.com/zhdoop/blogImg/raw/master/img/宽依赖.png)

宽依赖工作的时候, 不能随意在某些记录上运行, 而是需要使用特殊的方式(比如按照 key)来获取分区中的所有数据.

例如: 在排序(**sort**)的时候, 数据必须被分区, 同样范围的 **key** 必须在同一个分区内. 具有宽依赖的 **transformations** 包括: **sort**, **reduceByKey**, **groupByKey**, **join**, 和调用**rePartition**函数的任何操作.

### 2.7 Spark Job 的划分

由于 Spark 的懒执行, 在驱动程序调用一个**action**之前, Spark 应用不会做任何事情.

针对每个 **action**, Spark 调度器就创建一个执行图(execution graph)和启动一个 **Spark job**

每个 job 由多个**stages** 组成, 这些 **stages** 就是实现最终的 RDD 所需的数据转换的步骤. 一个宽依赖划分一个 stage.

每个 **stage** 由多个 **tasks** 来组成, 这些 **tasks** 就表示每个并行计算, 并且会在多个执行器上执行.

![SparkJob划分](https://gitee.com/zhdoop/blogImg/raw/master/img/Spark-Job-Task-split.png)

#### 2.7.1 DAG(Directed Acyclic Graph) 有向无环图

Spark 的顶层调度层使用 RDD 的依赖为每个 job 创建一个由 stages 组成的 DAG(有向无环图). 在 Spark API 中, 这被称作 DAG 调度器(DAG Scheduler).

我们已经注意到, 有些错误, 比如: 连接集群的错误, 配置参数错误, 启动一个 Spark job 的错误, 这些错误必须处理, 并且都表现为 DAG Scheduler 错误. 这是因为一个 Spark job 的执行是被 DAG 来处理.

DAG 为每个 job 构建一个 stages 组成的图表, 从而确定运行每个 task 的位置, 然后传递这些信息给 TaskSheduler. TaskSheduler 负责在集群中运行任务.

#### 2.7.2 Jobs

Spark job 处于 Spark 执行层级结构中的最高层. 每个 Spark job 对应一个 action, 每个 action 被 Spark 应用中的驱动所程序调用.

可以把 Action 理解成把数据从 RDD 的数据带到其他存储系统的组件(通常是带到驱动程序所在的位置或者写到稳定的存储系统中)

只要一个 action 被调用, Spark 就不会再向这个 job 增加新的东西.

#### 2.7.3 stages

前面说过, RDD 的转换是懒执行的, 直到调用一个 action 才开始执行 RDD 的转换.

正如前面所提到的, 一个 job 是由调用一个 action 来定义的. 一个 action 可能会包含一个或多个转换( transformation ), Spark 根据宽依赖把 job 分解成 stage.

从整体来看, 一个 stage 可以任务是“计算(task)”的集合, 这些每个“计算”在各自的 Executor 中进行运算, 而不需要同其他的执行器或者驱动进行网络通讯. 换句话说, 当任何两个 workers 之间开始需要网络通讯的时候, 这时候一个新的 stage 就产生了, 例如: shuffle 的时候.

这些创建 stage 边界的依赖称为 **ShuffleDependencies**. shuffle 是由宽依赖所引起的, 比如: **sort**, **groupBy**, 因为他们需要在分区中重新分发数据. 那些窄依赖的转换会被分到同一个 stage 中.

想想我们以前学习的 “worldcount 案例”

```scala
sc.textFile("/input")
	.flatMap(_.split(" "))
	.map((_,1))
	.reduceByKey(_ + _)
	.saveAsTextFile("/result")
```

Spark 会把 **flatMap**, **map** 合并到一个 stage 中, 因为这些转换不需要 shuffle. 所以, 数据只需要传递一次, 每个执行器就可以顺序的执行这些操作.

 因为边界 stage 需要同驱动进行通讯, 所以与 job 有关的 stage 通常必须顺序执行而不能并行执行.

如果这个 stage 是用来计算不同的 RDDs, 被用来合并成一个下游的转换(比如: **join**), 也是有可能并行执行的. 但是仅需要计算一个 RDD 的宽依赖转换必须顺序计算.

所以, 设计程序的时候, 尽量少用 **shuffle**.

#### 2.7.4 Tasks

stage 由 tasks 组成. 在执行层级中, task 是最小的执行单位. 每一个 task 表现为一个本地计算.

一个 stage 中的所有 tasks 会对不同的数据执行相同的代码.(程序代码一样, 只是作用在了不同的数据上)

一个 task 不能被多个执行器来执行, 但是, 每个执行器会动态的分配多个 slots 来执行 tasks, 并且在整个生命周期内会并行的运行多个 task. 每个 stage 的 task 的数量对应着分区的数量, 即每个 Partition 都被分配一个 Task 

![Tasks划分案例](https://gitee.com/zhdoop/blogImg/raw/master/img/Tasks1.png)

![Task划分示意图](https://gitee.com/zhdoop/blogImg/raw/master/img/Task的划分.png)

在大多数情况下, 每个 stage 的所有 task 在下一个 stage 开启之前必须全部完成.

### 2.8 RDD 持久化

每碰到一个 Action 就会产生一个 job, 每个 job 开始计算的时候总是从这个 job 最开始的 RDD 开始计算.

#### 2.8.1 先看一段案例

```scala
package day04
import org.apache.spark.rdd.RDD
import org.apache.spark.{SparkConf, SparkContext}

object CacheDemo {
    def main(args: Array[String]): Unit = {
        val conf = new SparkConf().setAppName("Practice").setMaster("local[2]")
        val sc = new SparkContext(conf)

        val rdd1 = sc.parallelize(Array("ab", "bc"))
        val rdd2 = rdd1.flatMap(x => {
            println("flatMap...")
            x.split("")
        })
        val rdd3: RDD[(String, Int)] = rdd2.map(x => {
            (x, 1)
        })

        rdd3.collect.foreach(println)
        println("-----------")
        rdd3.collect.foreach(println)
    }
}
```

执行结果

![Spark持久化案例执行结果](https://gitee.com/zhdoop/blogImg/raw/master/img/Spark持久化案例执行结果.png)

说明:

1. 每调用一次 **collect**, 都会创建一个新的 job, 每个 job 总是从它血缘的起始开始计算. 所以, 会发现中间的这些计算过程都会重复的执行.

2. 原因是因为 **rdd**记录了整个计算过程. 如果计算的过程中出现哪个分区的数据损坏或丢失, 则可以从头开始计算来达到容错的目的.

#### 2.8.2 RDD数据的持久化

每个 job 都会重新进行计算, 在有些情况下是没有必要, 如何解决这个问题呢?

Spark 一个重要能力就是可以持久化数据集在内存中. 当我们持久化一个 RDD 时, 每个节点都会存储他在内存中计算的那些分区, 然后在其他的 action 中可以重用这些数据. 这个特性会让将来的 action 计算起来更快(通常块 10 倍). 对于迭代算法和快速交互式查询来说, 缓存(Caching)是一个关键工具.

可以使用方法**persist()**或者**cache()**来持久化一个 RDD. 在第一个 action 会计算这个 RDD, 然后把结果的存储到他的节点的内存中. Spark 的 Cache 也是容错: 如果 RDD 的任何一个分区的数据丢失了, Spark 会自动的重新计算.

RDD 的各个 Partition 是相对独立的, 因此只需要计算丢失的部分即可, 并不需要重算全部 Partition

另外, 允许我们对持久化的 RDD 使用不同的存储级别.

例如: 可以存在磁盘上, 存储在内存中(堆内存中), 跨节点做复本.

可以给**persist()**来传递存储级别. **cache()**方法是使用默认存储级别(**StorageLevel.MEMORY_ONLY**)的简写方法.

| Storage Level                          | Meaning                                                      |
| -------------------------------------- | ------------------------------------------------------------ |
| MEMORY_ONLY                            | Store RDD as deserialized Java objects in the JVM. If the RDD does not fit in memory, some partitions will not be cached and will be recomputed on the fly each time they’re needed. This is the default level. |
| MEMORY_AND_DISK                        | Store RDD as deserialized Java objects in the JVM. If the RDD does not fit in memory, store the partitions that don’t fit on disk, and read them from there when they’re needed. |
| MEMORY_ONLY_SER (Java and Scala)       | Store RDD as **serialized** Java objects (one byte array per partition). This is generally more space-efficient than deserialized objects, especially when using a [fast serializer](http://spark.apache.org/docs/2.1.1/tuning.html), but more CPU-intensive to read. |
| MEMORY_AND_DISK_SER (Java and Scala)   | Similar to MEMORY_ONLY_SER, but spill partitions that don’t fit in memory to disk instead of recomputing them on the fly each time they’re needed. |
| DISK_ONLY                              | Store the RDD partitions only on disk.                       |
| MEMORY_ONLY_2, MEMORY_AND_DISK_2, etc. | Same as the levels above, but replicate each partition on two cluster nodes. |
| OFF_HEAP (experimental)                | Similar to MEMORY_ONLY_SER, but store the data in [off-heap memory](#memory-management). This requires off-heap memory to be enabled. |

```scala
//rdd2.cache() 等价于rdd2.persist(StorgeLevel.MEMORY_ONLY)
rdd2.persist(StorgeLevel.MEMORY_ONLY)
```

![持久化后的结果](https://gitee.com/zhdoop/blogImg/raw/master/img/Spark持久化案例执行结果2.png)

说明：

1. 第一个 job 会计算 RDD2, 以后的 job 就不用再计算了.

2. 有一点需要说明的是, 即使我们不手动设置持久化, Spark 也会自动的对一些 shuffle 操作的中间数据做持久化操作(比如: reduceByKey). 这样做的目的是为了当一个节点 shuffle 失败了避免重新计算整个输入. 当时, 在实际使用的时候, 如果想重用数据, 仍然建议调用**persist** 或 **cache**

### 2.9 设置检查点

Spark 中对于数据的保存除了持久化操作之外，还提供了一种检查点的机制,检查点（本质是通过将RDD写入Disk做检查点）是为了通过 Lineage 做容错的辅助

Lineage 过长会造成容错成本过高，这样就不如在中间阶段做检查点容错，如果之后有节点出现问题而丢失分区，从做检查点的 RDD 开始重做 Lineage，就会减少开销。

检查点通过将数据写入到 HDFS 文件系统实现了 RDD 的检查点功能。

为当前 RDD 设置检查点。该函数将会创建一个二进制的文件，并存储到 checkpoint 目录中，该目录是用 **SparkContext.setCheckpointDir()**设置的。在 checkpoint 的过程中，该RDD 的所有依赖于父 RDD中 的信息将全部被移除。

对 RDD 进行 checkpoint 操作并不会马上被执行，必须执行 Action 操作才能触发, 在触发的时候需要对这个 RDD 重新计算.

```scala
package day04

import org.apache.spark.rdd.RDD
import org.apache.spark.{SparkConf, SparkContext}


object CheckPointDemo {
    def main(args: Array[String]): Unit = {
        // 要在SparkContext初始化之前设置, 都在无效
        System.setProperty("HADOOP_USER_NAME", "atguigu")
        val conf = new SparkConf().setAppName("Practice").setMaster("local[2]")
        val sc = new SparkContext(conf)
        // 设置 checkpoint的目录. 如果spark运行在集群上, 则必须是 hdfs 目录
        sc.setCheckpointDir("hdfs://hadoop201:9000/checkpoint")
        val rdd1 = sc.parallelize(Array("abc"))
        val rdd2: RDD[String] = rdd1.map(_ + " : " + System.currentTimeMillis())

        /*
        标记 RDD2的 checkpoint.
        RDD2会被保存到文件中(文件位于前面设置的目录中), 并且会切断到父RDD的引用, 也就是切断了它向上的血缘关系
        该函数必须在job被执行之前调用.
        强烈建议把这个RDD序列化到内存中, 否则, 把他保存到文件的时候需要重新计算.
         */
        rdd2.checkpoint()
        rdd2.collect().foreach(println)
        rdd2.collect().foreach(println)
        rdd2.collect().foreach(println)
    }
}
```

![checkPoint 结果](https://gitee.com/zhdoop/blogImg/raw/master/img/image-20201010141431247.png)

![checkPoint保存到内存中](https://gitee.com/zhdoop/blogImg/raw/master/img/image-20201010141438479.png)

持久化和**checkpoint**的区别

1. 持久化只是将数据保存在 BlockManager 中，而 RDD 的 Lineage 是不变的。但是**checkpoint** 执行完后，RDD 已经没有之前所谓的依赖 RDD 了，而只有一个强行为其设置的**checkpointRDD**，RDD 的 Lineage 改变了。

2.  持久化的数据丢失可能性更大，磁盘、内存都可能会存在数据丢失的情况。但是 **checkpoint** 的数据通常是存储在如 HDFS 等容错、高可用的文件系统，数据丢失可能性较小。

3. 注意: 默认情况下，如果某个 RDD 没有持久化，但是设置了**checkpoint**，会存在问题. 本来这个 job 都执行结束了，但是由于中间 RDD 没有持久化，checkpoint job 想要将 RDD 的数据写入外部文件系统的话，需要全部重新计算一次，再将计算出来的 RDD 数据 checkpoint到外部文件系统。 所以，建议对 **checkpoint()**的 RDD 使用持久化, 这样 RDD 只需要计算一次就可以了.

## 3 Key-Value 类型 RDD 的数据分区器

对于只存储 **value**的 RDD, 不需要分区器.

只有存储**Key-Value**类型的才会需要分区器.

Spark 目前支持 Hash 分区和 Range 分区，用户也可以自定义分区.

Hash 分区为当前的默认分区，Spark 中分区器直接决定了 RDD 中分区的个数、RDD 中每条数据经过 Shuffle 过程后属于哪个分区和 Reduce 的个数.

### 3.1 查看RDD的分区

1. value RDD 的分区器

   ```scala
   scala> val rdd1 = sc.parallelize(Array(10))
   rdd1: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[2] at parallelize at <console>:25
   
   scala> rdd1.partitioner
   res8: Option[org.apache.spark.Partitioner] = None
   ```

2. key-value RDD的分区器

   ```scala
   scala> val rdd1 = sc.parallelize(Array(("hello", 1), ("world", 1)))
   rdd1: org.apache.spark.rdd.RDD[(String, Int)] = ParallelCollectionRDD[3] at parallelize at <console>:25
   
   scala> rdd1.partitioner
   res11: Option[org.apache.spark.Partitioner] = None
   
   // 导入HashPartitioner
   import org.apache.spark.HashPartitioner
   // 对 rdd1 重新分区, 得到分区后的 RDD, 分区器使用 HashPartitioner
   scala> val rdd2 = rdd1.partitionBy(new HashPartitioner(3))
   rdd2: org.apache.spark.rdd.RDD[(String, Int)] = ShuffledRDD[5] at partitionBy at <console>:27
   
   scala> rdd2.partitioner
   res14: Option[org.apache.spark.Partitioner] = Some(org.apache.spark.HashPartitioner@3)
   ```
### 3.2 HashPartitioner

   **HashPartitioner**分区的原理：对于给定的**key**，计算其**hashCode**，并除以分区的个数取余，如果余数小于 0，则用**余数+分区的个数**（否则加0），最后返回的值就是这个**key**所属的分区**ID**。

```scala
def nonNegativeMod(x: Int,mod : Int): Int = {
    val rawMod = x % mod
    rawMod + (if(rawMod < 0) mod else 0)
}
```

```scala
package day01

import org.apache.spark.rdd.RDD
import org.apache.spark.{HashPartitioner, SparkConf, SparkContext}

object Test {
    def main(args: Array[String]): Unit = {
        val conf = new SparkConf().setAppName("Practice").setMaster("local[2]")
        val sc = new SparkContext(conf)
        val rdd1 = sc.parallelize(Array((10, "a"), (20, "b"), (30, "c"), (40, "d"), (50, "e"), (60, "f")))
        // 把分区号取出来, 检查元素的分区情况
        val rdd2: RDD[(Int, String)] = rdd1.mapPartitionsWithIndex((index, it) => it.map(x => (index, x._1 + " : " + x._2)))

        println(rdd2.collect.mkString(","))

        // 把 RDD1使用 HashPartitioner重新分区
        val rdd3 = rdd1.partitionBy(new HashPartitioner(5))
        // 检测RDD3的分区情况
        val rdd4: RDD[(Int, String)] = rdd3.mapPartitionsWithIndex((index, it) => it.map(x => (index, x._1 + " : " + x._2)))
        println(rdd4.collect.mkString(","))
    }
}
```

![分区结果](https://gitee.com/zhdoop/blogImg/raw/master/img/image-20201014111129975.png)

### 3.3 RangePartitioner

**HashPartitioner** 分区弊端： 可能导致每个分区中数据量的不均匀，极端情况下会导致某些分区拥有 RDD 的全部数据。比如我们前面的例子就是一个极端, 他们都进入了 0 分区.

**RangePartitioner** 作用：将一定范围内的数映射到某一个分区内，尽量保证每个分区中数据量的均匀，而且分区与分区之间是有序的，一个分区中的元素肯定都是比另一个分区内的元素小或者大，但是分区内的元素是不能保证顺序的。简单的说就是将一定范围内的数映射到某一个分区内。实现过程为：

第一步：先从整个 RDD 中抽取出样本数据，将样本数据排序，计算出每个分区的最大 **key** 值，形成一个**Array[KEY]**类型的数组变量 **rangeBounds**；(边界数组).

第二步：判断**key**在**rangeBounds**中所处的范围，给出该**key**值在下一个**RDD**中的分区**id**下标；该分区器要求 RDD 中的 **KEY** 类型必须是可以排序的.

比如[1,100,200,300,400]，然后对比传进来的**key**，返回对应的分区**id**

### 3.4 自定义分区器

要实现自定义的分区器，你需要继承 **org.apache.spark.Partitioner**, 并且需要实现下面的方法:

**numPartitions**

该方法需要返回分区数, 必须要大于0.

**getPartition(key)**

返回指定键的分区编号(0到numPartitions-1)。

**equals**

Java 判断相等性的标准方法。这个方法的实现非常重要，Spark 需要用这个方法来检查你的分区器对象是否和其他分区器实例相同，这样 Spark 才可以判断两个 RDD 的分区方式是否相同

**hashCode**

如果你覆写了**equals**, 则也应该覆写这个方法.

#### **MyPartitioner**

```scala
package day04

import org.apache.spark.rdd.RDD
import org.apache.spark.{Partitioner, SparkConf, SparkContext}
/*
使用自定义的 Partitioner 是很容易的 :只要把它传给 partitionBy() 方法即可。

Spark 中有许多依赖于数据混洗的方法，比如 join() 和 groupByKey()，
它们也可以接收一个可选的 Partitioner 对象来控制输出数据的分区方式。
*/
object MyPartitionerDemo {
    def main(args: Array[String]): Unit = {
        val conf = new SparkConf().setAppName("Practice").setMaster("local[*]")
        val sc = new SparkContext(conf)

        val rdd1 = sc.parallelize(
            Array((10, "a"), (20, "b"), (30, "c"), (40, "d"), (50, "e"), (60, "f")),
            3)
        val rdd2: RDD[(Int, String)] = rdd1.partitionBy(new MyPartitioner(4))
        val rdd3: RDD[(Int, String)] = rdd2.mapPartitionsWithIndex((index, items) => items.map(x => (index, x._1 + " : " + x._2)))
        println(rdd3.collect.mkString(" "))

    }
}

class MyPartitioner(numPars: Int) extends Partitioner {
    override def numPartitions: Int = numPars


    override def getPartition(key: Any): Int = {
        1
    }
}
```

## 4 文件中数据的读取和保存

本章专门学习如何从文件中读取数据和保存数据到文件中.

从文件中读取数据是创建 RDD 的一种方式.

把数据保存的文件中的操作是一种 Action.

Spark 的数据读取及数据保存可以从两个维度来作区分：文件格式以及文件系统。

文件格式分为：Text文件、Json文件、csv文件、Sequence文件以及Object文件；

文件系统分为：本地文件系统、HDFS、Hbase 以及 数据库。

平时用的比较多的就是: 从 HDFS 读取和保存 Text 文件.

### 4.1 读写Text文件

```scala
// 读取本地文件
scala> val rdd1 = sc.textFile("./words.txt")
rdd1: org.apache.spark.rdd.RDD[String] = ./words.txt MapPartitionsRDD[5] at textFile at <console>:24
scala> val rdd2 = rdd1.flatMap(_.split(" ")).map((_, 1)).reduceByKey(_ +_)
rdd2: org.apache.spark.rdd.RDD[(String, Int)] = ShuffledRDD[8] at reduceByKey at <console>:26
// 保存数据到 hdfs 上.        
scala> rdd2.saveAsTextFile("hdfs://hadoop201:9000/words_output")
```

![Text文件保存结果](https://gitee.com/zhdoop/blogImg/raw/master/img/image-20201014141222994.png)

### 4.2 读取 Json 文件

如果 JSON 文件中每一行就是一个 JSON 记录，那么可以通过将 JSON 文件当做文本文件来读取，然后利用相关的 JSON 库对每一条数据进行 JSON 解析。

注意：使用 RDD 读取 JSON 文件处理很复杂，同时 SparkSQL 集成了很好的处理 JSON 文件的方式，所以实际应用中多是采用SparkSQL处理JSON文件。

关于 SparkSQL 后面的章节专门去讲

```scala
// 读取 json 数据的文件, 每行是一个 json 对象
scala> val rdd1 = sc.textFile("/opt/module/spark-local/examples/src/main/resources/people.json")
rdd1: org.apache.spark.rdd.RDD[String] = /opt/module/spark-local/examples/src/main/resources/people.json MapPartitionsRDD[11] at textFile at <console>:24
// 导入 scala 提供的可以解析 json 的工具类
scala> import scala.util.parsing.json.JSON
import scala.util.parsing.json.JSON

// 使用 map 来解析 Json, 需要传入 JSON.parseFull
scala> val rdd2 = rdd1.map(JSON.parseFull)
rdd2: org.apache.spark.rdd.RDD[Option[Any]] = MapPartitionsRDD[12] at map at <console>:27

// 解析到的结果其实就是 Option 组成的数组, Option 存储的就是 Map 对象
scala> rdd2.collect
res2: Array[Option[Any]] = Array(Some(Map(name -> Michael)), Some(Map(name -> Andy, age -> 30.0)), Some(Map(name -> Justin, age -> 19.0)))
```

### 4.3 读取SequenceFile 文件

SequenceFile 文件是 Hadoop 用来存储二进制形式的 key-value 对而设计的一种平面文件(Flat File)。

Spark 有专门用来读取 SequenceFile 的接口。在 SparkContext 中，可以调用 **sequenceFile[ keyClass, valueClass](path)**。

注意：SequenceFile 文件只针对 PairRDD

#### 4.3.1 先保存一个 SequenceFile 文件

```scala
scala> val rdd1 = sc.parallelize(Array(("a", 1),("b", 2),("c", 3)))
rdd1: org.apache.spark.rdd.RDD[(String, Int)] = ParallelCollectionRDD[13] at parallelize at <console>:25

scala> rdd1.saveAsSequenceFile("hdfs://hadoop201:9000/seqFiles")
```

![SequenceFile 文件保存结果](https://gitee.com/zhdoop/blogImg/raw/master/img/image-20201014141634558.png)

#### 4.3.2 读取SequenceFile 文件

```scala
scala> val rdd1 = sc.sequenceFile[String, Int]("hdfs://hadoop201:9000/seqFiles")
rdd1: org.apache.spark.rdd.RDD[(String, Int)] = MapPartitionsRDD[18] at sequenceFile at <console>:25

scala> rdd1.collect
res4: Array[(String, Int)] = Array((a,1), (b,2), (c,3))
注意: 需要指定泛型的类型 sc.sequenceFile[String, Int]
```

### 4.4 读取 objectFile 文件

对象文件是将对象序列化后保存的文件，采用 Java 的序列化机制。

可以通过**objectFile[k,v](path)** 函数接收一个路径，读取对象文件，返回对应的 RDD，也可以通过调用**saveAsObjectFile()** 实现对对象文件的输出

#### 4.4.1 把RDD保存为 objectFile

```shell
scala> val rdd1 = sc.parallelize(Array(("a", 1),("b", 2),("c", 3)))
rdd1: org.apache.spark.rdd.RDD[(String, Int)] = ParallelCollectionRDD[19] at parallelize at <console>:25

scala> rdd1.saveAsObjectFile("hdfs://hadoop201:9000/obj_file")
```

![objectFile 保存结果](https://gitee.com/zhdoop/blogImg/raw/master/img/image-20201014142020292.png)

#### 4.4.2 读取objectFile

```scala
scala> val rdd1 = sc.objectFile[(String, Int)]("hdfs://hadoop201:9000/obj_file")
rdd1: org.apache.spark.rdd.RDD[(String, Int)] = MapPartitionsRDD[25] at objectFile at <console>:25

scala> rdd1.collect
res8: Array[(String, Int)] = Array((a,1), (b,2), (c,3))
```

### 4.5 从HDFS 读写文件

Spark 的整个生态系统与 Hadoop 完全兼容的,所以对于 Hadoop 所支持的文件类型或者数据库类型,Spark 也同样支持.

另外,由于 Hadoop 的 API 有新旧两个版本,所以 Spark 为了能够兼容 Hadoop 所有的版本,也提供了两套创建操作接口.

对于外部存储创建操作而言,HadoopRDD 和 newHadoopRDD 是最为抽象的两个函数接口,主要包含以下四个参数.

1. 输入格式(InputFormat): 制定数据输入的类型,如 TextInputFormat 等,新旧两个版本所引用的版本分别是 org.apache.hadoop.mapred.InputFormat 和org.apache.hadoop.mapreduce.InputFormat(NewInputFormat)

2. 键类型: 指定[K,V]键值对中K的类型

3. 值类型: 指定[K,V]键值对中V的类型

4. 分区值: 指定由外部存储生成的RDD的partition数量的最小值,如果没有指定,系统会使用默认值defaultMinSplits

注意:其他创建操作的API接口都是为了方便最终的Spark程序开发者而设置的,是这两个接口的高效实现版本.例如,对于textFile而言,只有path这个指定文件路径的参数,其他参数在系统内部指定了默认值。

1.  在Hadoop中以压缩形式存储的数据,不需要指定解压方式就能够进行读取,因为Hadoop本身有一个解压器会根据压缩文件的后缀推断解压算法进行解压.

2.  如果用Spark从Hadoop中读取某种类型的数据不知道怎么读取的时候,上网查找一个使用map-reduce的时候是怎么读取这种这种数据的,然后再将对应的读取方式改写成上面的hadoopRDD和newAPIHadoopRDD两个类就行了

### 4.6 从Mysql 数据读写文件

引入 Mysql 依赖:

```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>5.1.27</version>
</dependency>
```

从Mysql读取数据

```scala
package day04

import java.sql.DriverManager

import org.apache.spark.rdd.JdbcRDD
import org.apache.spark.{SparkConf, SparkContext}

object JDBCDemo {
    def main(args: Array[String]): Unit = {
        val conf = new SparkConf().setAppName("Practice").setMaster("local[2]")
        val sc = new SparkContext(conf)
        //定义连接mysql的参数
        val driver = "com.mysql.jdbc.Driver"
        val url = "jdbc:mysql://hadoop201:3306/rdd"
        val userName = "root"
        val passWd = "aaa"

        val rdd = new JdbcRDD(
            sc,
            () => {
                Class.forName(driver)
                DriverManager.getConnection(url, userName, passWd)
            },
            "select id, name from user where id >= ? and id <= ?",
            1,
            20,
            2,
            result => (result.getInt(1), result.getString(2))
        )
        rdd.collect.foreach(println)

    }
}
```

向mysql写入数据

```scala
package day04

import java.sql.{Connection, DriverManager, PreparedStatement}

import org.apache.spark.rdd.RDD
import org.apache.spark.{SparkConf, SparkContext}

object JDBCDemo2 {
    def main(args: Array[String]): Unit = {
        val conf = new SparkConf().setAppName("Practice").setMaster("local[2]")
        val sc = new SparkContext(conf)
        //定义连接mysql的参数
        val driver = "com.mysql.jdbc.Driver"
        val url = "jdbc:mysql://hadoop201:3306/rdd"
        val userName = "root"
        val passWd = "aaa"

        val rdd: RDD[(Int, String)] = sc.parallelize(Array((110, "police"), (119, "fire")))
        // 对每个分区执行 参数函数
        rdd.foreachPartition(it => {
            Class.forName(driver)
            val conn: Connection = DriverManager.getConnection(url, userName, passWd)
            it.foreach(x => {
                val statement: PreparedStatement = conn.prepareStatement("insert into user values(?, ?)")
                statement.setInt(1, x._1)
                statement.setString(2, x._2)
                statement.executeUpdate()
            })
        })
    }
}
```

### 4.7 从Hbase 读写文件

由于org.apache.hadoop.hbase.mapreduce.TableInputFormat 类的实现，Spark可以通过Hadoop输入格式访问HBase。

这个输入格式会返回键值对数据，其中键的类型为org.apache.hadoop.hbase.io.ImmutableBytesWritable,而值的类型为 org.apache.hadoop.hbase.client.Result

导入依赖

```xml
<dependency>
    <groupId>org.apache.hbase</groupId>
    <artifactId>hbase-server</artifactId>
    <version>1.3.1</version>
    <exclusions>
        <exclusion>
            <groupId>org.mortbay.jetty</groupId>
            <artifactId>servlet-api-2.5</artifactId>
        </exclusion>
        <exclusion>
            <groupId>javax.servlet</groupId>
            <artifactId>servlet-api</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

**从HBase读取数据**

```scala
package day04

import org.apache.hadoop.conf.Configuration
import org.apache.hadoop.hbase.HBaseConfiguration
import org.apache.hadoop.hbase.client.Result
import org.apache.hadoop.hbase.io.ImmutableBytesWritable
import org.apache.hadoop.hbase.mapreduce.TableInputFormat
import org.apache.hadoop.hbase.util.Bytes
import org.apache.spark.rdd.RDD
import org.apache.spark.{SparkConf, SparkContext}

object HBaseDemo {
    def main(args: Array[String]): Unit = {
        val conf = new SparkConf().setAppName("Practice").setMaster("local[2]")
        val sc = new SparkContext(conf)

        val hbaseConf: Configuration = HBaseConfiguration.create()
        hbaseConf.set("hbase.zookeeper.quorum", "node1,node2,node3")
        hbaseConf.set(TableInputFormat.INPUT_TABLE, "student")

        val rdd: RDD[(ImmutableBytesWritable, Result)] = sc.newAPIHadoopRDD(
            hbaseConf,
            classOf[TableInputFormat],
            classOf[ImmutableBytesWritable],
            classOf[Result])

        val rdd2: RDD[String] = rdd.map {
            case (_, result) => Bytes.toString(result.getRow)
        }
        rdd2.collect.foreach(println)
        sc.stop()
    }
}
```

**向HBase写入数据**

```shell
package day04

import org.apache.hadoop.hbase.HBaseConfiguration
import org.apache.hadoop.hbase.client.Put
import org.apache.hadoop.hbase.io.ImmutableBytesWritable
import org.apache.hadoop.hbase.mapreduce.TableOutputFormat
import org.apache.hadoop.hbase.util.Bytes
import org.apache.hadoop.mapreduce.Job
import org.apache.spark.{SparkConf, SparkContext}

object HBaseDemo2 {

    def main(args: Array[String]): Unit = {
        val conf = new SparkConf().setAppName("Practice").setMaster("local[2]")
        val sc = new SparkContext(conf)

        val hbaseConf = HBaseConfiguration.create()
        hbaseConf.set("hbase.zookeeper.quorum", "node1,noed2,node3")
        hbaseConf.set(TableOutputFormat.OUTPUT_TABLE, "student")
        // 通过job来设置输出的格式的类
        val job = Job.getInstance(hbaseConf)
        job.setOutputFormatClass(classOf[TableOutputFormat[ImmutableBytesWritable]])
        job.setOutputKeyClass(classOf[ImmutableBytesWritable])
        job.setOutputValueClass(classOf[Put])

        val initialRDD = sc.parallelize(List(("100", "apple", "11"), ("200", "banana", "12"), ("300", "pear", "13")))
        val hbaseRDD = initialRDD.map(x => {
            val put = new Put(Bytes.toBytes(x._1))
            put.addColumn(Bytes.toBytes("info"), Bytes.toBytes("name"), Bytes.toBytes(x._2))
            put.addColumn(Bytes.toBytes("info"), Bytes.toBytes("weight"), Bytes.toBytes(x._3))
            (new ImmutableBytesWritable(), put)
        })
        hbaseRDD.saveAsNewAPIHadoopDataset(job.getConfiguration)
    }
}
```

## 5 RDD编程进阶

### 5.1 共享变量问题

看下面的代码

```shell
package day04

import org.apache.spark.rdd.RDD
import org.apache.spark.{SparkConf, SparkContext}

object AccDemo1 {
    def main(args: Array[String]): Unit = {
        val conf = new SparkConf().setAppName("Practice").setMaster("local[2]")
        val sc = new SparkContext(conf)
        val p1 = Person(10)
        // 将来会把对象序列化之后传递到每个节点上
        val rdd1 = sc.parallelize(Array(p1))
        val rdd2: RDD[Person] = rdd1.map(p => {p.age = 100; p})

        rdd2.count()
        // 仍然是 10
        println(p1.age)
    }
}

case class Person(var age:Int)
```

正常情况下, 传递给 Spark 算子(比如: **map**, **reduce** 等)的函数都是在远程的集群节点上执行, 函数中用到的所有变量都是独立的拷贝.

这些变量被拷贝到集群上的每个节点上, 都这些变量的更改不会传递回驱动程序.

支持跨 task 之间共享变量通常是低效的, 但是 Spark 对共享变量也提供了两种支持:

1. 累加器

2. 广播变量

### 5.2 累加器（Accumulator）

累加器用来对信息进行聚合。通常在向Spark传递函数时，比如使用map()函数或者用filter()传条件时，可以使用驱动器程序中定义的变量，但是集群中运行的每个任务都会得到这些变量的一份新的副本，所以更新这些副本的值不会影响驱动器中的对应变量。

如果我们想实现所有分片处理时更新共享变量的功能，那么累加器可以实现我们想要的效果。

累加器是一种变量, 仅仅支持“add”, 支持并发. 累加器用于去实现计数器或者求和. Spark 内部已经支持数字类型的累加器, 开发者可以添加其他类型的支持.

**内置累加器**

需求：计算文件中空行的数量

```scala
package day04

import org.apache.spark.rdd.RDD
import org.apache.spark.util.LongAccumulator
import org.apache.spark.{SparkConf, SparkContext}

object AccDemo1 {
    def main(args: Array[String]): Unit = {
        val conf = new SparkConf().setAppName("Practice").setMaster("local[2]")
        val sc = new SparkContext(conf)
        val rdd: RDD[String] = sc.textFile("file://" + ClassLoader.getSystemResource("words.txt").getPath)
         // 得到一个 Long 类型的累加器.  将从 0 开始累加
        val emptyLineCount: LongAccumulator = sc.longAccumulator
        rdd.foreach(s => if (s.trim.length == 0) emptyLineCount.add(1))
        println(emptyLineCount.value)
    }
}
```

说明：

1. 在驱动程序中通过sc.longAccumulator 得到Long 类型的累加器，还有Double类型的

2. 可以通过value来访问累加器的值，与（sum等价）。avg得到平均值

3. 只能通过add 来添加值

4. 累加器的更新操作最好放在action 中，Spark 可以保证每个task 只只执行一次，如果放在transformations 操作中则不能保证只更新一次，有可能会被重复执行。


**自定义累加器**

通过继承类**AccumulatorV2**来自定义累加器.

下面这个累加器可以用于在程序运行过程中收集一些文本类信息，最终以List[String]的形式返回。

```scala
package day04

import java.util
import java.util.{ArrayList, Collections}

import org.apache.spark.util.AccumulatorV2

object MyAccDemo {
    def main(args: Array[String]): Unit = {

    }
}

class MyAcc extends AccumulatorV2[String, java.util.List[String]] {
    private val _list: java.util.List[String] = Collections.synchronizedList(new ArrayList[String]())
    override def isZero: Boolean = _list.isEmpty

    override def copy(): AccumulatorV2[String, util.List[String]] = {
        val newAcc = new MyAcc
        _list.synchronized {
            newAcc._list.addAll(_list)
        }
        newAcc
    }

    override def reset(): Unit = _list.clear()

    override def add(v: String): Unit = _list.add(v)
    override def merge(other: AccumulatorV2[String, util.List[String]]): Unit =other match {
        case o: MyAcc => _list.addAll(o.value)
        case _ => throw new UnsupportedOperationException(
            s"Cannot merge ${this.getClass.getName} with ${other.getClass.getName}")
    }

    override def value: util.List[String] = java.util.Collections.unmodifiableList(new util.ArrayList[String](_list))
}
```

   测试

```scala
object MyAccDemo {
    def main(args: Array[String]): Unit = {
        val pattern = """^\d+$"""
        val conf = new SparkConf().setAppName("Practice").setMaster("local[2]")
        val sc = new SparkContext(conf)
        // 统计出来非纯数字, 并计算纯数字元素的和
        val rdd1 = sc.parallelize(Array("abc", "a30b", "aaabb2", "60", "20"))

        val acc = new MyAcc
        sc.register(acc)
        val rdd2: RDD[Int] = rdd1.filter(x => {
            val flag: Boolean = x.matches(pattern)
            if (!flag) acc.add(x)
            flag
        }).map(_.toInt)
        println(rdd2.reduce(_ + _))
        println(acc.value)
    }
}
```

注意:

在使用自定义累加器的不要忘记注册**sc.register(acc)**

结果：

```
80
[aaabb2,abc,a30b]
```

### 5.3 广播变量

广播变量在每个节点保存一个只读的变量的缓存, 而不用给每个 task 来传送一个 copy。例如, 给每个节点一个比较大的输入数据集是一个比较高效的方法. Spark 也会用该对象的广播逻辑去分发广播变量来降低通讯的成本。

广播变量通过调用**SparkContext.broadcast(v)**来创建. 广播变量是对**v**的包装, 通过调用广播变量的 **value**方法可以访问.

```scala
scala> val broadcastVar = sc.broadcast(Array(1, 2, 3))
broadcastVar: org.apache.spark.broadcast.Broadcast[Array[Int]] = Broadcast(0)

scala> broadcastVar.value
res0: Array[Int] = Array(1, 2, 3)
```

说明：

1. 通过对一类型T的对象调用SparkContext.broadcast 创建一个Broadcast[T]对象。任何可序列化的类型都可以这么实现的。
2. 通过value属性访问该对象的值（在Java中为value()方法）
3. 变量只会被发到各个节点上一次，应作为只读值处理(修改这个值不会影响到别的节点)。